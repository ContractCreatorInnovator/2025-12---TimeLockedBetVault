// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

contract TimeLockedBetVaultETH {
    using SafeERC20 for IERC20;
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;


    /*//////////////////////////////////////////////////////////////
                              ROLES
    //////////////////////////////////////////////////////////////*/

    address internal constant _BETTOR1 = 0x5Df1B9398857148106bb27ABd3ab1a30BA298449;
    address internal constant _BETTOR2 = 0x99f2AaFB4E43eFA5d42fa2E44e3791c4d2005770;
    address internal constant _JUDGE = 0x7dD7624608445744DE04DB07ed6761346a281b3e;

    function BETTOR1() public pure returns (address) { return _BETTOR1; }
    function BETTOR2() public pure returns (address) { return _BETTOR2; }
    function JUDGE()   public pure returns (address) { return _JUDGE; }

    /*//////////////////////////////////////////////////////////////
                              TIME
    //////////////////////////////////////////////////////////////*/

    uint256 public constant LOCK_UNTIL = 1767225600;              // Jan 1, 2027
    uint256 public constant SAFETY_WITHDRAWAL_DATE = 1798761600; // Jan 1, 2028

    /*//////////////////////////////////////////////////////////////
                              STATE
    //////////////////////////////////////////////////////////////*/

    address[] private tokenList;
    mapping(address => bool) public tokenRegistered;
    mapping(address => bool) public tokenWithdrawn;

    bool public ethWithdrawn;
    bool public paused;
    bool public hasDeposits;

    uint256 public pauseNonce;
    uint256 public withdrawNonce;

    /*//////////////////////////////////////////////////////////////
                              EVENTS
    //////////////////////////////////////////////////////////////*/

    event TokenRegistered(address token);
    event TokensDeposited(address indexed from, address indexed token, uint256 amount);
    event ETHDeposited(address indexed from, uint256 amount);
    event TokenWithdrawn(address indexed token, address indexed winner, uint256 amount);
    event ETHWithdrawn(address indexed winner, uint256 amount);
    event SafetyWithdrawalExecuted();
    event Paused(bool status);

    /*//////////////////////////////////////////////////////////////
                              MODIFIERS
    //////////////////////////////////////////////////////////////*/

    modifier notPaused() {
        require(!paused, "Paused");
        _;
    }

    modifier onlyBettor() {
        require(msg.sender == BETTOR1() || msg.sender == BETTOR2(), "Only bettors");
        _;
    }

    modifier onlyParticipant() {
        require(
            msg.sender == BETTOR1() ||
            msg.sender == BETTOR2() ||
            msg.sender == JUDGE(),
            "Not authorized"
        );
        _;
    }

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor() {
        require(BETTOR1() != address(0) && BETTOR2() != address(0) && JUDGE() != address(0), "Unset role");
        require(BETTOR1() != BETTOR2(), "Same bettor");
        require(BETTOR1() != JUDGE() && BETTOR2() != JUDGE(), "Role overlap");
    }

    /*//////////////////////////////////////////////////////////////
                          ADMIN / SAFETY
    //////////////////////////////////////////////////////////////*/

    function pauseWithSignatures(bool _paused, bytes[] calldata sigs) external {
        bytes32 messageHash = keccak256(
            abi.encode("pause", _paused, address(this), block.chainid, pauseNonce)
        ).toEthSignedMessageHash();

        uint256 valid = _countValidSigners(messageHash, sigs);
        require(valid >= 2, "Need 2 of 3 signatures");

        paused = _paused;
        pauseNonce++;
        emit Paused(_paused);
    }

    /*//////////////////////////////////////////////////////////////
                          DEPOSIT (TOKENS & ETH)
    //////////////////////////////////////////////////////////////*/

    function depositToken(address token, uint256 amount)
        external
        notPaused
        onlyBettor
    {
        require(token != address(0), "Invalid token");
        require(amount > 0, "Zero amount");

        if (!tokenRegistered[token]) {
            tokenRegistered[token] = true;
            tokenList.push(token);
            emit TokenRegistered(token);
        }

        hasDeposits = true;
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);

        emit TokensDeposited(msg.sender, token, amount);
    }

    function depositETH() external payable notPaused onlyBettor {
        require(msg.value > 0, "Zero ETH");
        hasDeposits = true;
        emit ETHDeposited(msg.sender, msg.value);
    }

    /*//////////////////////////////////////////////////////////////
                    SIGNATURE VERIFICATION (2-of-3)
    //////////////////////////////////////////////////////////////*/

    function _isValidSigner(address signer) internal pure returns (bool) {
        return signer == BETTOR1() || signer == BETTOR2() || signer == JUDGE();
    }

    function _countValidSigners(bytes32 ethHash, bytes[] calldata sigs)
        internal
        pure
        returns (uint256 count)
    {
        address[3] memory seen;

        for (uint256 i; i < sigs.length; i++) {
            address signer = ethHash.recover(sigs[i]);
            if (_isValidSigner(signer)) {
                bool duplicate;
                for (uint256 j; j < count; j++) {
                    if (seen[j] == signer) duplicate = true;
                }
                if (!duplicate) {
                    seen[count++] = signer;
                }
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL SPLIT HELPERS
    //////////////////////////////////////////////////////////////*/

    function _splitToken(address token) internal {
        uint256 bal = IERC20(token).balanceOf(address(this));
        if (bal > 0) {
            uint256 half = bal / 2;
            IERC20(token).safeTransfer(BETTOR1(), half);
            IERC20(token).safeTransfer(BETTOR2(), bal - half);
        }
        tokenWithdrawn[token] = true;
        withdrawNonce++;
        emit TokenWithdrawn(token, address(0), bal);
    }

    function _splitETH() internal {
        uint256 bal = address(this).balance;
        require(bal > 0, "No ETH");

        uint256 half = bal / 2;
        payable(BETTOR1()).call{value: half}("");
        payable(BETTOR2()).call{value: bal - half}("");

        ethWithdrawn = true;
        withdrawNonce++;
        emit ETHWithdrawn(address(0), bal);
    }

    /*//////////////////////////////////////////////////////////////
                        WITHDRAW TOKEN
    //////////////////////////////////////////////////////////////*/

    function withdrawToken(
        address token,
        address winner,
        bytes[] calldata sigs
    ) external notPaused {
        require(block.timestamp >= LOCK_UNTIL, "Locked");
        require(tokenRegistered[token], "Unknown token");
        require(!tokenWithdrawn[token], "Already withdrawn");

        if (block.timestamp >= SAFETY_WITHDRAWAL_DATE) {
            _splitToken(token);
            return;
        }

        require(winner == BETTOR1() || winner == BETTOR2(), "Invalid winner");

        bytes32 messageHash = keccak256(
            abi.encode(
                "withdrawToken",
                token,
                winner,
                address(this),
                block.chainid,
                withdrawNonce
            )
        ).toEthSignedMessageHash();

        uint256 valid = _countValidSigners(messageHash, sigs);
        require(valid >= 2, "Need 2-of-3 approval");

        uint256 bal = IERC20(token).balanceOf(address(this));
        if (bal > 0) {
            IERC20(token).safeTransfer(winner, bal);
        }
        tokenWithdrawn[token] = true;
        withdrawNonce++;

        emit TokenWithdrawn(token, winner, bal);
    }

    /*//////////////////////////////////////////////////////////////
                        WITHDRAW ETH
    //////////////////////////////////////////////////////////////*/

    function withdrawETH(
        address winner,
        bytes[] calldata sigs
    ) external notPaused {
        require(block.timestamp >= LOCK_UNTIL, "Locked");
        require(!ethWithdrawn, "ETH withdrawn");

        if (block.timestamp >= SAFETY_WITHDRAWAL_DATE) {
            _splitETH();
            return;
        }

        require(winner == BETTOR1() || winner == BETTOR2(), "Invalid winner");

        bytes32 messageHash = keccak256(
            abi.encode(
                "withdrawETH",
                winner,
                address(this),
                block.chainid,
                withdrawNonce
            )
        ).toEthSignedMessageHash();

        uint256 valid = _countValidSigners(messageHash, sigs);
        require(valid >= 2, "Need 2-of-3 approval");

        ethWithdrawn = true;
        withdrawNonce++;

        uint256 bal = address(this).balance;
        require(bal > 0, "No ETH");

        (bool ok, ) = payable(winner).call{value: bal}("");
        require(ok, "ETH transfer failed");

        emit ETHWithdrawn(winner, bal);
    }

    /*//////////////////////////////////////////////////////////////
                        SAFETY WITHDRAWAL
    //////////////////////////////////////////////////////////////*/

    function safetyWithdrawal() external notPaused onlyParticipant {
        require(block.timestamp >= SAFETY_WITHDRAWAL_DATE, "Too early");

        for (uint256 i; i < tokenList.length; i++) {
            address token = tokenList[i];
            if (!tokenWithdrawn[token]) {
                uint256 bal = IERC20(token).balanceOf(address(this));
                if (bal > 0) {
                    uint256 half = bal / 2;
                    IERC20(token).safeTransfer(BETTOR1(), half);
                    IERC20(token).safeTransfer(BETTOR2(), bal - half);
                }
                tokenWithdrawn[token] = true;
            }
        }

        if (!ethWithdrawn && address(this).balance > 0) {
            uint256 half = address(this).balance / 2;
            payable(BETTOR1()).call{value: half}("");
            payable(BETTOR2()).call{value: address(this).balance}("");
            ethWithdrawn = true;
        }

        emit SafetyWithdrawalExecuted();
    }

    /*//////////////////////////////////////////////////////////////
                          VIEW HELPERS
    //////////////////////////////////////////////////////////////*/

    function getAllTokens() external view returns (address[] memory) {
        return tokenList;
    }
}
